<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>assorted_functions &mdash; iMSminer_beta 0.0.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
      <link rel="stylesheet" href="../_static/fonts.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            iMSminer_beta
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">iMSminer_beta</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">assorted_functions</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for assorted_functions</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">@author: Yu Tin Lin (yutinlin@stanford.edu)</span>
<span class="sd">@author: Haohui Bao (susanab20020911@gmail.com)</span>
<span class="sd">@author: Boone M. Prentice (booneprentice@ufl.chem.edu)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">matplotlib.offsetbox</span> <span class="kn">import</span> <span class="n">OffsetImage</span><span class="p">,</span> <span class="n">AnnotationBbox</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">from</span> <span class="nn">sklearn.manifold</span> <span class="kn">import</span> <span class="n">TSNE</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">calinski_harabasz_score</span><span class="p">,</span> <span class="n">davies_bouldin_score</span><span class="p">,</span> <span class="n">silhouette_score</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span>
<span class="kn">import</span> <span class="nn">psutil</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">find_peaks</span><span class="p">,</span> <span class="n">peak_widths</span>
<span class="kn">from</span> <span class="nn">bokeh.plotting</span> <span class="kn">import</span> <span class="n">figure</span><span class="p">,</span> <span class="n">show</span><span class="p">,</span> <span class="n">save</span><span class="p">,</span> <span class="n">output_file</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">typing</span> <span class="k">as</span> <span class="nn">ty</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="s2">&quot;/home/yutinlin/workspace/iMSminer&quot;</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">utilities</span> <span class="kn">import</span> <span class="n">check_xy</span><span class="p">,</span> <span class="n">convert_peak_values_to_index</span><span class="p">,</span> <span class="n">convert_peak_values_to_index_gpu</span><span class="p">,</span> <span class="n">generate_function</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">time_loop</span>
<span class="kn">import</span> <span class="nn">ImzMLParser_chunk</span>
<span class="kn">from</span> <span class="nn">ImzMLParser_chunk</span> <span class="kn">import</span> <span class="n">ImzMLParser_chunk</span>
<span class="kn">import</span> <span class="nn">ray</span>
<span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cupy is installed and imported successfully!&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cupy is not installed or could not be imported.&quot;</span><span class="p">)</span>


<span class="k">if</span> <span class="ow">not</span> <span class="n">ray</span><span class="o">.</span><span class="n">is_initialized</span><span class="p">():</span>
    <span class="n">ray</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">num_cpus</span><span class="o">=</span><span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Enter a number of CPUs to use for processing: &quot;</span><span class="p">))</span>


<span class="n">METHODS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;pchip&quot;</span><span class="p">,</span> <span class="s2">&quot;zero&quot;</span><span class="p">,</span> <span class="s2">&quot;slinear&quot;</span><span class="p">,</span>
           <span class="s2">&quot;quadratic&quot;</span><span class="p">,</span> <span class="s2">&quot;cubic&quot;</span><span class="p">,</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;gpu_linear&quot;</span><span class="p">]</span>
<span class="n">LOGGER</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="Aligner_CPU"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.Aligner_CPU">[docs]</a><span class="k">class</span> <span class="nc">Aligner_CPU</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alignment class from https://github.com/lukasz-migas/msalign</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">        @software{msalign2024,</span>
<span class="sd">        author = {Lukasz G. Migas},</span>
<span class="sd">        title = {{msalign}: Spectral alignment based on MATLAB&#39;s `msalign` function.},</span>
<span class="sd">        url = {https://github.com/lukasz-migas/msalign},</span>
<span class="sd">        version = {0.2.0},</span>
<span class="sd">        year = {2024},</span>
<span class="sd">        }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_method</span><span class="p">,</span> <span class="n">_gaussian_ratio</span><span class="p">,</span> <span class="n">_gaussian_resolution</span><span class="p">,</span> <span class="n">_gaussian_width</span><span class="p">,</span> <span class="n">_n_iterations</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">_corr_sig_l</span><span class="p">,</span> <span class="n">_corr_sig_x</span><span class="p">,</span> <span class="n">_corr_sig_y</span><span class="p">,</span> <span class="n">_reduce_range_factor</span><span class="p">,</span> <span class="n">_scale_range</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">_search_space</span><span class="p">,</span> <span class="n">_computed</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">array</span><span class="p">:</span> <span class="n">ty</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">peaks</span><span class="p">:</span> <span class="n">ty</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cubic&quot;</span><span class="p">,</span>
        <span class="n">width</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">ratio</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span>
        <span class="n">resolution</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">grid_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
        <span class="n">shift_range</span><span class="p">:</span> <span class="n">ty</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">ty</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">ty</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">ty</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_shifts</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">align_by_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">only_shift</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Signal calibration and alignment by reference peaks</span>

<span class="sd">        A simplified version of the MSALIGN function found in MATLAB (see references for link)</span>

<span class="sd">        This version of the msalign function accepts most of the parameters that MATLAB&#39;s function accepts with the</span>
<span class="sd">        following exceptions: GroupValue, ShowPlotValue. A number of other parameters is allowed, although they have</span>
<span class="sd">        been renamed to comply with PEP8 conventions. The Python version is 8-60 times slower than the MATLAB</span>
<span class="sd">        implementation, which is mostly caused by a really slow instantiation of the</span>
<span class="sd">        `scipy.interpolate.PchipInterpolator` interpolator. In order to speed things up, I&#39;ve also included several</span>
<span class="sd">        other interpolation methods which are significantly faster and give similar results.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Monchamp, P., Andrade-Cetto, L., Zhang, J.Y., and Henson, R. (2007) Signal Processing Methods for Mass</span>
<span class="sd">        Spectrometry. In Systems Bioinformatics: An Engineering Case-Based Approach, G. Alterovitz and M.F. Ramoni, eds.</span>
<span class="sd">        Artech House Publishers).</span>
<span class="sd">        MSALIGN: https://nl.mathworks.com/help/bioinfo/ref/msalign.html</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : np.ndarray</span>
<span class="sd">            1D array of separation units (N). The number of elements of xvals must equal the number of elements of</span>
<span class="sd">            zvals.shape[1]</span>
<span class="sd">        array : np.ndarray</span>
<span class="sd">            2D array of intensities that must have common separation units (M x N) where M is the number of vectors</span>
<span class="sd">            and N is number of points in the vector</span>
<span class="sd">        peaks : list</span>
<span class="sd">            list of reference peaks that must be found in the xvals vector</span>
<span class="sd">        method : str</span>
<span class="sd">            interpolation method. Default: &#39;cubic&#39;. MATLAB version uses &#39;pchip&#39; which is significantly slower in Python</span>
<span class="sd">        weights: list (optional)</span>
<span class="sd">            list of weights associated with the list of peaks. Must be the same length as list of peaks</span>
<span class="sd">        width : float (optional)</span>
<span class="sd">            width of the gaussian peak in separation units. Default: 10</span>
<span class="sd">        ratio : float (optional)</span>
<span class="sd">            scaling value that determines the size of the window around every alignment peak. The synthetic signal is</span>
<span class="sd">            compared to the input signal within these regions. Default: 2.5</span>
<span class="sd">        resolution : int (optional)</span>
<span class="sd">            Default: 100</span>
<span class="sd">        iterations : int (optional)</span>
<span class="sd">            number of iterations. Increasing this value will (slightly) slow down the function but will improve</span>
<span class="sd">            performance. Default: 5</span>
<span class="sd">        grid_steps : int (optional)</span>
<span class="sd">            number of steps to be used in the grid search. Default: 20</span>
<span class="sd">        shift_range : list / numpy array (optional)</span>
<span class="sd">            maximum allowed shifts. Default: [-100, 100]</span>
<span class="sd">        only_shift : bool</span>
<span class="sd">            determines if signal should be shifted (True) or rescaled (False). Default: True</span>
<span class="sd">        return_shifts : bool</span>
<span class="sd">            decide whether shift parameter `shift_opt` should also be returned. Default: False</span>
<span class="sd">        align_by_index : bool</span>
<span class="sd">            decide whether alignment should be done based on index rather than `xvals` array. Default: False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">check_xy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array_aligned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>

        <span class="c1"># set attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">)</span>

        <span class="c1"># accessible attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift_opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift_opt</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_ratio</span> <span class="o">=</span> <span class="n">ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_resolution</span> <span class="o">=</span> <span class="n">resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_width</span> <span class="o">=</span> <span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iterations</span> <span class="o">=</span> <span class="n">iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_steps</span> <span class="o">=</span> <span class="n">grid_steps</span>
        <span class="k">if</span> <span class="n">shift_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shift_range</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift_range</span> <span class="o">=</span> <span class="n">shift_range</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>

        <span class="c1"># return shift vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_shifts</span> <span class="o">=</span> <span class="n">return_shifts</span>
        <span class="c1"># If the number of points is equal to 1, then only shift</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">only_shift</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">only_shift</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">align_by_index</span><span class="p">:</span>
            <span class="n">align_by_index</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Only computing shifts - changed `align_by_index` to `True`.&quot;</span><span class="p">)</span>

        <span class="c1"># align signals by index rather than peak value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_align_by_index</span> <span class="o">=</span> <span class="n">align_by_index</span>
        <span class="c1"># align by index - rather than aligning to arbitrary non-integer values in the xvals, you can instead</span>
        <span class="c1"># use index of those values</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align_by_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span> <span class="o">=</span> <span class="n">convert_peak_values_to_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Aligning by index - peak positions: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_only_shift</span> <span class="o">=</span> <span class="n">only_shift</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolation method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_method</span>

    <span class="nd">@method</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">METHODS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Method `</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">` not found in the method options: </span><span class="si">{</span><span class="n">METHODS</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_method</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gaussian_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gaussian ratio.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussian_ratio</span>

    <span class="nd">@gaussian_ratio</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">gaussian_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Value of &#39;ratio&#39; must be above 0!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gaussian_ratio</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gaussian_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gaussian resolution of every Gaussian pulse (number of points).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussian_resolution</span>

    <span class="nd">@gaussian_resolution</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">gaussian_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Value of &#39;resolution&#39; must be above 0!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gaussian_resolution</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gaussian_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Width of the Gaussian pulse in std dev of the Gaussian pulses (in X).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gaussian_width</span>

    <span class="nd">@gaussian_width</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">gaussian_width</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gaussian_width</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Total number of iterations - increase to improve accuracy.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_iterations</span>

    <span class="nd">@n_iterations</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">n_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Value of &#39;iterations&#39; must be above 0 and be an integer!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_iterations</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grid_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Total number of iterations - increase to improve accuracy.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_steps</span>

    <span class="nd">@grid_steps</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">grid_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Value of &#39;iterations&#39; must be above 0 and be an integer!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid_steps</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shift_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Total number of iterations - increase to improve accuracy.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shift_range</span>

    <span class="nd">@shift_range</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">shift_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ty</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Number of &#39;shift_values&#39; is not correct. Shift range accepts&quot;</span> <span class="s2">&quot; numpy array with two values.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Values of &#39;shift_values&#39; must not be the same!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shift_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Total number of iterations - increase to improve accuracy.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span>

    <span class="nd">@weights</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ty</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">ty</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]]):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ty</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Weights must be provided as an iterable.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Number of weights does not match the number of peaks.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare dataset for alignment&quot;&quot;&quot;</span>
        <span class="c1"># check that values for gaussian_width are valid</span>
        <span class="n">gaussian_widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">):</span>
            <span class="n">gaussian_widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_width</span>

        <span class="c1"># set the synthetic target signal</span>
        <span class="n">corr_sig_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">gaussian_resolution</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">))</span>
        <span class="n">corr_sig_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">gaussian_resolution</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">))</span>

        <span class="n">gaussian_resolution_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_resolution</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">):</span>
            <span class="n">left_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_ratio</span> <span class="o">*</span> <span class="n">gaussian_widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># noqa</span>
            <span class="n">right_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_ratio</span> <span class="o">*</span> <span class="n">gaussian_widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># noqa</span>
            <span class="n">corr_sig_x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">left_l</span> <span class="o">+</span> <span class="p">(</span><span class="n">gaussian_resolution_range</span> <span class="o">*</span>
                                         <span class="p">(</span><span class="n">right_l</span> <span class="o">-</span> <span class="n">left_l</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_resolution</span><span class="p">)</span>
            <span class="n">corr_sig_y</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">((</span><span class="n">corr_sig_x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">gaussian_widths</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c1"># noqa</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_l</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gaussian_resolution</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_x</span> <span class="o">=</span> <span class="n">corr_sig_x</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_y</span> <span class="o">=</span> <span class="n">corr_sig_y</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>

        <span class="c1"># set reduce_range_factor to take 5 points of the previous ranges or half of</span>
        <span class="c1"># the previous range if grid_steps &lt; 10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_range_factor</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">5</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_steps</span><span class="p">)</span>

        <span class="c1"># set scl such that the maximum peak can shift no more than the limits imposed by shift when scaling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale_range</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_range</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_only_shift</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scale_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># create the mesh-grid only once</span>
        <span class="n">mesh_a</span><span class="p">,</span> <span class="n">mesh_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_steps</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_steps</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_search_space</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">mesh_a</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">),</span> <span class="n">mesh_b</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="p">[</span>
                <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_iterations</span><span class="p">]</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Aligner_CPU.run"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.Aligner_CPU.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute the alignment procedure for each signal in the 2D array and collate the shift/scale vectors&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iterations</span> <span class="o">=</span> <span class="n">n_iterations</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iterations</span>
        <span class="c1"># iterate for every signal</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># main loop: searches for the optimum values of Scale and Shift factors by search over a multi-resolution</span>
        <span class="c1"># grid, getting better at each iteration. Increasing the number of iterations improves the shift and scale</span>
        <span class="c1"># parameters</span>
        <span class="k">for</span> <span class="n">n_signal</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shift_opt</span><span class="p">[</span><span class="n">n_signal</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_opt</span><span class="p">[</span><span class="n">n_signal</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span>
                <span class="n">y</span><span class="p">)</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processed </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span><span class="si">}</span><span class="s2"> signals &quot;</span> <span class="o">+</span>
                     <span class="n">time_loop</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_computed</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Aligner_CPU.compute"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.Aligner_CPU.compute">[docs]</a>    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ty</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute correction factors.</span>

<span class="sd">        This function does not set value in any of the class attributes so can be used in a iterator where values</span>
<span class="sd">        are computed lazily.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_scale_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
        <span class="n">scale_opt</span><span class="p">,</span> <span class="n">shift_opt</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span>

        <span class="c1"># set to back to the user input arguments (or default)</span>
        <span class="n">_shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_range</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_range</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># generate interpolation function for each signal - instantiation of the interpolator can be quite slow,</span>
        <span class="c1"># so you can slightly increase the number of iterations without significant slowdown of the process</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">generate_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="c1"># iterate to estimate the shift and scale - at each iteration, the grid search is readjusted and the</span>
        <span class="c1"># shift/scale values are optimized further</span>
        <span class="k">for</span> <span class="n">n_iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iterations</span><span class="p">):</span>
            <span class="c1"># scale and shift search space</span>
            <span class="n">scale_grid</span> <span class="o">=</span> <span class="n">_scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_space</span><span class="p">[:,</span>
                                                        <span class="p">(</span><span class="n">n_iter</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_scale</span><span class="p">)</span>
            <span class="n">shift_grid</span> <span class="o">=</span> <span class="n">_shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_space</span><span class="p">[:,</span>
                                                        <span class="p">(</span><span class="n">n_iter</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_shift</span><span class="p">)</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">scale_grid</span><span class="p">,</span> <span class="p">(</span><span class="n">scale_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_l</span><span class="p">))</span>
                <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">shift_grid</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_l</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="p">)</span>
            <span class="c1"># interpolate at each iteration. Need to remove NaNs which can be introduced by certain (e.g.</span>
            <span class="c1"># PCHIP) interpolator</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

            <span class="c1"># determine the best position</span>
            <span class="n">i_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_y</span><span class="p">)</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>

            <span class="c1"># save optimum value</span>
            <span class="n">scale_opt</span> <span class="o">=</span> <span class="n">scale_grid</span><span class="p">[</span><span class="n">i_max</span><span class="p">]</span>
            <span class="n">shift_opt</span> <span class="o">=</span> <span class="n">shift_grid</span><span class="p">[</span><span class="n">i_max</span><span class="p">]</span>

            <span class="c1"># readjust grid for next iteration_reduce_range_factor</span>
            <span class="n">_scale</span> <span class="o">=</span> <span class="n">scale_opt</span> <span class="o">+</span> <span class="n">_scale_range</span> <span class="o">*</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_scale</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_range_factor</span>
            <span class="n">_shift</span> <span class="o">=</span> <span class="n">shift_opt</span> <span class="o">+</span> <span class="n">_scale_range</span> <span class="o">*</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_shift</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_range_factor</span>
        <span class="k">return</span> <span class="n">shift_opt</span><span class="p">,</span> <span class="n">scale_opt</span></div>

<div class="viewcode-block" id="Aligner_CPU.apply"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.Aligner_CPU.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_shifts</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Align the signals against the computed values&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_computed</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Aligning data without computing optimal alignment parameters&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_shifts</span> <span class="o">=</span> <span class="n">return_shifts</span> <span class="k">if</span> <span class="n">return_shifts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_shifts</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_only_shift</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">()</span>

        <span class="c1"># return aligned data and shifts</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_shifts</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_aligned</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_values</span>
        <span class="c1"># only return data</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_aligned</span></div>

<div class="viewcode-block" id="Aligner_CPU.align"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.Aligner_CPU.align">[docs]</a>    <span class="k">def</span> <span class="nf">align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift_opt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_opt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Realign array based on the optimized shift and scale parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shift_opt: Optional[np.ndarray]</span>
<span class="sd">            vector containing values by which to shift the array</span>
<span class="sd">        scale_opt : Optional[np.ndarray]</span>
<span class="sd">            vector containing values by which to rescale the array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">shift_opt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shift_opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_opt</span>
        <span class="k">if</span> <span class="n">scale_opt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale_opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_opt</span>

        <span class="c1"># realign based on provided values</span>
        <span class="k">for</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
            <span class="c1"># interpolate back to the original domain</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array_aligned</span><span class="p">[</span><span class="n">iteration</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span>
                <span class="n">y</span><span class="p">,</span> <span class="n">shift_opt</span><span class="p">[</span><span class="n">iteration</span><span class="p">],</span> <span class="n">scale_opt</span><span class="p">[</span><span class="n">iteration</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_opt</span>

        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Re-aligned </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span><span class="si">}</span><span class="s2"> signals &quot;</span> <span class="o">+</span>
                     <span class="n">time_loop</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">shift_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">scale_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply alignment correction to array `y`.&quot;&quot;&quot;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">generate_function</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">shift_value</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale_value</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>

<div class="viewcode-block" id="Aligner_CPU.shift"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.Aligner_CPU.shift">[docs]</a>    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift_opt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Quickly shift array based on the optimized shift parameters.</span>

<span class="sd">        This method does not interpolate but rather moves the data left and right without applying any scaling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shift_opt: Optional[np.ndarray]</span>
<span class="sd">            vector containing values by which to shift the array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">shift_opt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shift_opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift_opt</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># quickly shift based on provided values</span>
        <span class="k">for</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array_aligned</span><span class="p">[</span><span class="n">iteration</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span><span class="p">(</span>
                <span class="n">y</span><span class="p">,</span> <span class="n">shift_opt</span><span class="p">[</span><span class="n">iteration</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift_values</span> <span class="o">=</span> <span class="n">shift_opt</span>

        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Re-aligned </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span><span class="si">}</span><span class="s2"> signals &quot;</span> <span class="o">+</span>
                     <span class="n">time_loop</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span><span class="p">))</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_shift</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">shift_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply shift correction to array `y`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">shift</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">shift_value</span><span class="p">))</span></div>


<div class="viewcode-block" id="Aligner_GPU"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.Aligner_GPU">[docs]</a><span class="k">class</span> <span class="nc">Aligner_GPU</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alignment class refactored from https://github.com/lukasz-migas/msalign</span>

<span class="sd">    Cite the following if used:</span>
<span class="sd">        @software{msalign2024,</span>
<span class="sd">        author = {Lukasz G. Migas},</span>
<span class="sd">        title = {{msalign}: Spectral alignment based on MATLAB&#39;s `msalign` function.},</span>
<span class="sd">        url = {https://github.com/lukasz-migas/msalign},</span>
<span class="sd">        version = {0.2.0},</span>
<span class="sd">        year = {2024},</span>
<span class="sd">        }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">x</span><span class="p">:</span> <span class="n">cp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                 <span class="n">peaks</span><span class="p">:</span> <span class="n">ty</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                 <span class="n">array</span><span class="p">:</span> <span class="n">ty</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                 <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;gpu_linear&quot;</span><span class="p">,</span>
                 <span class="n">n_iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
                 <span class="n">shift_range</span><span class="p">:</span> <span class="n">ty</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">ty</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">return_shifts</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">grid_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                 <span class="n">resolution</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                 <span class="n">width</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                 <span class="n">ratio</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span>
                 <span class="n">only_shift</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">weights</span><span class="p">:</span> <span class="n">ty</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">ty</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">align_by_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iterations</span> <span class="o">=</span> <span class="n">n_iterations</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">check_xy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">array_aligned</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shift_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shift_range</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift_range</span> <span class="o">=</span> <span class="n">shift_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_scale_range</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_range</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_steps</span> <span class="o">=</span> <span class="n">grid_steps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_only_shift</span> <span class="o">=</span> <span class="n">only_shift</span>
        <span class="c1"># If the number of points is equal to 1, then only shift</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">only_shift</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">only_shift</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">align_by_index</span><span class="p">:</span>
            <span class="n">align_by_index</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Only computing shifts - changed `align_by_index` to `True`.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_range_factor</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">5</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_steps</span><span class="p">)</span>

        <span class="c1"># accessible attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_opt</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift_opt</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift_values</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift_opt</span><span class="p">)</span>
        <span class="c1"># return shift vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_shifts</span> <span class="o">=</span> <span class="n">return_shifts</span>

        <span class="c1"># create the mesh-grid only once</span>
        <span class="n">mesh_a</span><span class="p">,</span> <span class="n">mesh_b</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_steps</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_steps</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_search_space</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">mesh_a</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">),</span> <span class="n">mesh_b</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="p">[</span>
                <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_iterations</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_resolution</span> <span class="o">=</span> <span class="n">resolution</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_l</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gaussian_resolution</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span>

        <span class="c1"># set the synthetic target signal</span>
        <span class="n">corr_sig_x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">gaussian_resolution</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">))</span>
        <span class="n">corr_sig_y</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">gaussian_resolution</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_x</span> <span class="o">=</span> <span class="n">corr_sig_x</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_y</span> <span class="o">=</span> <span class="n">corr_sig_y</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>

        <span class="c1"># align signals by index rather than peak value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_align_by_index</span> <span class="o">=</span> <span class="n">align_by_index</span>
        <span class="c1"># align by index - rather than aligning to arbitrary non-integer values in the xvals, you can instead</span>
        <span class="c1"># use index of those values</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align_by_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span> <span class="o">=</span> <span class="n">convert_peak_values_to_index_gpu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Aligning by index - peak positions: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_width</span> <span class="o">=</span> <span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_ratio</span> <span class="o">=</span> <span class="n">ratio</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolation method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_method</span>

    <span class="nd">@method</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">METHODS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Method `</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">` not found in the method options: </span><span class="si">{</span><span class="n">METHODS</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_method</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grid_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Total number of iterations - increase to improve accuracy.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_steps</span>

    <span class="nd">@grid_steps</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">grid_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Value of &#39;iterations&#39; must be above 0 and be an integer!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid_steps</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Total number of iterations - increase to improve accuracy.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_iterations</span>

    <span class="nd">@n_iterations</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">n_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Value of &#39;iterations&#39; must be above 0 and be an integer!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_iterations</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="Aligner_GPU.run"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.Aligner_GPU.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute the alignment procedure for each signal in the 2D array and collate the shift/scale vectors&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iterations</span> <span class="o">=</span> <span class="n">n_iterations</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iterations</span>
        <span class="c1"># iterate for every signal</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># main loop: searches for the optimum values of Scale and Shift factors by search over a multi-resolution</span>
        <span class="c1"># grid, getting better at each iteration. Increasing the number of iterations improves the shift and scale</span>
        <span class="c1"># parameters</span>
        <span class="k">for</span> <span class="n">n_signal</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shift_opt</span><span class="p">[</span><span class="n">n_signal</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_opt</span><span class="p">[</span><span class="n">n_signal</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span>
                <span class="n">y</span><span class="p">)</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processed </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span><span class="si">}</span><span class="s2"> signals &quot;</span> <span class="o">+</span>
                     <span class="n">time_loop</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_computed</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Aligner_GPU.run_batch"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.Aligner_GPU.run_batch">[docs]</a>    <span class="k">def</span> <span class="nf">run_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute the alignment procedure for the entire batch of signals and collate the shift/scale vectors.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iterations</span> <span class="o">=</span> <span class="n">n_iterations</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iterations</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># Process all signals at once using the modified compute function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift_opt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_batch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>

        <span class="c1"># Here, use appropriate logging to account for CuPy/GPU execution if needed</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processed </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> signals in </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t_start</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_computed</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Aligner_GPU.compute_batch"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.Aligner_GPU.compute_batch">[docs]</a>    <span class="k">def</span> <span class="nf">compute_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Y</span><span class="p">:</span> <span class="n">cp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ty</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute correction factors for a batch of signals.</span>

<span class="sd">        :param Y: 2D CuPy array where each row is a signal.</span>
<span class="sd">        :return: Two 1D CuPy arrays containing the shift and scale optimizations for each signal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_scale_range</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>

        <span class="c1"># Initialize arrays to hold the optimal scale and shift for each signal</span>
        <span class="n">scale_opts</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">shift_opts</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">_shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_range</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_range</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">funcs</span> <span class="o">=</span> <span class="n">generate_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n_iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iterations</span><span class="p">):</span>
            <span class="n">scale_grid</span> <span class="o">=</span> <span class="n">_scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_space</span><span class="p">[:,</span>
                                                        <span class="p">(</span><span class="n">n_iter</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_scale</span><span class="p">)</span>
            <span class="n">shift_grid</span> <span class="o">=</span> <span class="n">_shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_space</span><span class="p">[:,</span>
                                                        <span class="p">(</span><span class="n">n_iter</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_shift</span><span class="p">)</span>

            <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">scale_grid</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_x</span> <span class="o">+</span> <span class="n">shift_grid</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">funcs</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale_grid</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

            <span class="c1"># Find the best position for each signal</span>
            <span class="n">i_max</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_y</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Update optimum values</span>
            <span class="n">scale_opts</span> <span class="o">=</span> <span class="n">scale_grid</span><span class="p">[</span><span class="n">i_max</span><span class="p">]</span>
            <span class="n">shift_opts</span> <span class="o">=</span> <span class="n">shift_grid</span><span class="p">[</span><span class="n">i_max</span><span class="p">]</span>

            <span class="c1"># Readjust grid for next iteration</span>
            <span class="n">_scale</span> <span class="o">=</span> <span class="n">scale_opts</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">_scale_range</span> <span class="o">*</span> \
                <span class="n">cp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_scale</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_range_factor</span>
            <span class="n">_shift</span> <span class="o">=</span> <span class="n">shift_opts</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">_scale_range</span> <span class="o">*</span> \
                <span class="n">cp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_shift</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_range_factor</span>

        <span class="k">return</span> <span class="n">shift_opts</span><span class="p">,</span> <span class="n">scale_opts</span></div>

<div class="viewcode-block" id="Aligner_GPU.apply"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.Aligner_GPU.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_shifts</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Align the signals against the computed values&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_computed</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Aligning data without computing optimal alignment parameters&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_shifts</span> <span class="o">=</span> <span class="n">return_shifts</span> <span class="k">if</span> <span class="n">return_shifts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_shifts</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_only_shift</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">()</span>

        <span class="c1"># return aligned data and shifts</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_shifts</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_aligned</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_values</span>
        <span class="c1"># only return data</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_aligned</span></div>

<div class="viewcode-block" id="Aligner_GPU.align"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.Aligner_GPU.align">[docs]</a>    <span class="k">def</span> <span class="nf">align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift_opt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_opt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Realign array based on the optimized shift and scale parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shift_opt: Optional[np.ndarray]</span>
<span class="sd">            vector containing values by which to shift the array</span>
<span class="sd">        scale_opt : Optional[np.ndarray]</span>
<span class="sd">            vector containing values by which to rescale the array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">shift_opt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shift_opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_opt</span>
        <span class="k">if</span> <span class="n">scale_opt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale_opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_opt</span>

        <span class="c1"># realign based on provided values</span>
        <span class="k">for</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
            <span class="c1"># interpolate back to the original domain</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array_aligned</span><span class="p">[</span><span class="n">iteration</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span>
                <span class="n">y</span><span class="p">,</span> <span class="n">shift_opt</span><span class="p">[</span><span class="n">iteration</span><span class="p">],</span> <span class="n">scale_opt</span><span class="p">[</span><span class="n">iteration</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_opt</span></div>

    <span class="k">def</span> <span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">cp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">shift_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">scale_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply alignment correction to array `y`.&quot;&quot;&quot;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">generate_function</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">shift_value</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale_value</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cp</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>

<div class="viewcode-block" id="Aligner_GPU.compute"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.Aligner_GPU.compute">[docs]</a>    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">cp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ty</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute correction factors.</span>

<span class="sd">        This function does not set value in any of the class attributes so can be used in a iterator where values</span>
<span class="sd">        are computed lazily.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_scale_range</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
        <span class="n">scale_opt</span><span class="p">,</span> <span class="n">shift_opt</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span>

        <span class="c1"># set to back to the user input arguments (or default)</span>
        <span class="n">_shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_range</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_range</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># generate interpolation function for each signal - instantiation of the interpolator can be quite slow,</span>
        <span class="c1"># so you can slightly increase the number of iterations without significant slowdown of the process</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">generate_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="c1"># iterate to estimate the shift and scale - at each iteration, the grid search is readjusted and the</span>
        <span class="c1"># shift/scale values are optimized further</span>
        <span class="k">for</span> <span class="n">n_iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iterations</span><span class="p">):</span>
            <span class="c1"># scale and shift search space</span>
            <span class="n">scale_grid</span> <span class="o">=</span> <span class="n">_scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_space</span><span class="p">[:,</span>
                                                        <span class="p">(</span><span class="n">n_iter</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_scale</span><span class="p">)</span>
            <span class="n">shift_grid</span> <span class="o">=</span> <span class="n">_shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_space</span><span class="p">[:,</span>
                                                        <span class="p">(</span><span class="n">n_iter</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_shift</span><span class="p">)</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">cp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">scale_grid</span><span class="p">,</span> <span class="p">(</span><span class="n">scale_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_l</span><span class="p">))</span>
                <span class="o">+</span> <span class="n">cp</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">shift_grid</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_l</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="p">)</span>
            <span class="c1"># interpolate at each iteration. Need to remove NaNs which can be introduced by certain (e.g.</span>
            <span class="c1"># PCHIP) interpolator</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

            <span class="c1"># determine the best position</span>
            <span class="n">i_max</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_y</span><span class="p">)</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>

            <span class="c1"># save optimum value</span>
            <span class="n">scale_opt</span> <span class="o">=</span> <span class="n">scale_grid</span><span class="p">[</span><span class="n">i_max</span><span class="p">]</span>
            <span class="n">shift_opt</span> <span class="o">=</span> <span class="n">shift_grid</span><span class="p">[</span><span class="n">i_max</span><span class="p">]</span>

            <span class="c1"># readjust grid for next iteration_reduce_range_factor</span>
            <span class="n">_scale</span> <span class="o">=</span> <span class="n">scale_opt</span> <span class="o">+</span> <span class="n">_scale_range</span> <span class="o">*</span> \
                <span class="n">cp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_scale</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_range_factor</span>
            <span class="n">_shift</span> <span class="o">=</span> <span class="n">shift_opt</span> <span class="o">+</span> <span class="n">_scale_range</span> <span class="o">*</span> \
                <span class="n">cp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_shift</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_range_factor</span>
        <span class="k">return</span> <span class="n">shift_opt</span><span class="p">,</span> <span class="n">scale_opt</span></div>

    <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare dataset for alignment&quot;&quot;&quot;</span>
        <span class="c1"># check that values for gaussian_width are valid</span>
        <span class="n">gaussian_widths</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">):</span>
            <span class="n">gaussian_widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_width</span>

        <span class="c1"># set the synthetic target signal</span>
        <span class="n">corr_sig_x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">gaussian_resolution</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">))</span>
        <span class="n">corr_sig_y</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">gaussian_resolution</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">))</span>

        <span class="n">gaussian_resolution_range</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_resolution</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">):</span>
            <span class="n">left_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_ratio</span> <span class="o">*</span> <span class="n">gaussian_widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># noqa</span>
            <span class="n">right_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_ratio</span> <span class="o">*</span> <span class="n">gaussian_widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># noqa</span>
            <span class="n">corr_sig_x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">left_l</span> <span class="o">+</span> <span class="p">(</span><span class="n">gaussian_resolution_range</span> <span class="o">*</span>
                                         <span class="p">(</span><span class="n">right_l</span> <span class="o">-</span> <span class="n">left_l</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_resolution</span><span class="p">)</span>
            <span class="n">corr_sig_y</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                <span class="o">-</span><span class="n">cp</span><span class="o">.</span><span class="n">square</span><span class="p">((</span><span class="n">corr_sig_x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">gaussian_widths</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c1"># noqa</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_l</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gaussian_resolution</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_x</span> <span class="o">=</span> <span class="n">corr_sig_x</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_corr_sig_y</span> <span class="o">=</span> <span class="n">corr_sig_y</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>

        <span class="c1"># set reduce_range_factor to take 5 points of the previous ranges or half of</span>
        <span class="c1"># the previous range if grid_steps &lt; 10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_range_factor</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">5</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_steps</span><span class="p">)</span>

        <span class="c1"># set scl such that the maximum peak can shift no more than the limits imposed by shift when scaling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale_range</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_range</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_only_shift</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scale_range</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># create the mesh-grid only once</span>
        <span class="n">mesh_a</span><span class="p">,</span> <span class="n">mesh_b</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_steps</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_steps</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_search_space</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">mesh_a</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">),</span> <span class="n">mesh_b</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="p">[</span>
                <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_iterations</span><span class="p">]</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Aligner_GPU.shift"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.Aligner_GPU.shift">[docs]</a>    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift_opt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Quickly shift array based on the optimized shift parameters.</span>

<span class="sd">        This method does not interpolate but rather moves the data left and right without applying any scaling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shift_opt: Optional[np.ndarray]</span>
<span class="sd">            vector containing values by which to shift the array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">shift_opt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shift_opt</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift_opt</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># quickly shift based on provided values</span>
        <span class="k">for</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array_aligned</span><span class="p">[</span><span class="n">iteration</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span><span class="p">(</span>
                <span class="n">y</span><span class="p">,</span> <span class="n">shift_opt</span><span class="p">[</span><span class="n">iteration</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift_values</span> <span class="o">=</span> <span class="n">shift_opt</span>

        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Re-aligned </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span><span class="si">}</span><span class="s2"> signals &quot;</span> <span class="o">+</span>
                     <span class="n">time_loop</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_signals</span><span class="p">))</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_shift</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="n">cp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">shift_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply shift correction to array `y`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">shift</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">shift_value</span><span class="p">))</span></div>


<div class="viewcode-block" id="significance"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.significance">[docs]</a><span class="k">def</span> <span class="nf">significance</span><span class="p">(</span><span class="n">pvalue</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">pvalue</span> <span class="o">&lt;=</span> <span class="mf">0.001</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;***&quot;</span>
    <span class="k">elif</span> <span class="n">pvalue</span> <span class="o">&lt;=</span> <span class="mf">0.01</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;**&quot;</span>
    <span class="k">elif</span> <span class="n">pvalue</span> <span class="o">&lt;=</span> <span class="mf">0.05</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;*&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;ns&quot;</span></div>


<div class="viewcode-block" id="get_chunk_ms_info"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.get_chunk_ms_info">[docs]</a><span class="k">def</span> <span class="nf">get_chunk_ms_info</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">chunk_start</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a dictionary of intensity, m/z, and coordinate values by iterating through a chunk of imzML data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p: pyimzml.ImzMLParser</span>
<span class="sd">        Instace of ImzMLParser class containing imported imzML data</span>

<span class="sd">    chunk_start: int</span>
<span class="sd">        Pixel index for the start of chunk</span>

<span class="sd">    chunk_size: int</span>
<span class="sd">        Number of pixels contained in each chunk</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ms_dict: dictionary of 2 key:value pairs</span>
<span class="sd">        Key `I` contains the intensity matrix of axes pixel index and m/z bin index</span>
<span class="sd">        Key `mz` contains m/z values</span>
<span class="sd">        Key `coords` contains pixel indices and coordinate values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ms_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">index_stop</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">getspectrum</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mf">0.999</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">chunk_start</span><span class="p">:</span><span class="n">chunk_start</span><span class="o">+</span><span class="n">chunk_size</span><span class="p">]):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">chunk_start</span> <span class="o">+</span> <span class="n">idx</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">mzs</span><span class="p">,</span> <span class="n">intensities</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">getspectrum</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;mz&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mzs</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">index_stop</span><span class="p">]</span>
        <span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intensities</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">index_stop</span><span class="p">])</span>
        <span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
    <span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">])</span>
    <span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">ms_dict</span></div>


<div class="viewcode-block" id="get_chunk_ms_info2"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.get_chunk_ms_info2">[docs]</a><span class="k">def</span> <span class="nf">get_chunk_ms_info2</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">chunk_start</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a dictionary of intensity, m/z, and coordinate values from a chunk of imzML data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p: pyimzml.ImzMLParser</span>
<span class="sd">        Instace of ImzMLParser class containing imported imzML data</span>

<span class="sd">    chunk_start: int</span>
<span class="sd">        Pixel index for the start of chunk</span>

<span class="sd">    chunk_size: int</span>
<span class="sd">        Number of pixels contained in each chunk</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ms_dict: dictionary of 2 key:value pairs</span>
<span class="sd">        Key `I` contains the intensity matrix of axes pixel index and m/z bin index</span>
<span class="sd">        Key `mz` contains m/z values</span>
<span class="sd">        Key `coords` contains pixel indices and coordinate values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ms_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">index_stop</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">getmz</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mf">0.999</span><span class="p">)</span>

    <span class="c1"># should pixel 0 be chosen? looks like mz is same across indices</span>
    <span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;mz&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">getmz</span><span class="p">(</span><span class="mi">0</span><span class="p">)[:</span><span class="n">index_stop</span><span class="p">]</span>

    <span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get_intensity_chunk</span><span class="p">(</span><span class="n">chunk_start</span><span class="o">=</span><span class="n">chunk_start</span><span class="p">,</span> <span class="n">chunk_end</span><span class="o">=</span><span class="p">(</span>
        <span class="n">chunk_start</span><span class="o">+</span><span class="n">chunk_size</span><span class="p">),</span> <span class="n">index_stop</span><span class="o">=</span><span class="n">index_stop</span><span class="p">)</span>
    <span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">][:,</span> <span class="p">:</span><span class="n">index_stop</span><span class="p">]</span>

    <span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
        <span class="n">p</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">chunk_start</span><span class="p">:(</span><span class="n">chunk_start</span><span class="o">+</span><span class="n">chunk_size</span><span class="p">)])</span>

    <span class="k">return</span> <span class="n">ms_dict</span></div>


<div class="viewcode-block" id="get_chunk_ms_info_inhomogeneous"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.get_chunk_ms_info_inhomogeneous">[docs]</a><span class="k">def</span> <span class="nf">get_chunk_ms_info_inhomogeneous</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">chunk_start</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="n">max_mz</span><span class="p">,</span> <span class="n">min_mz</span><span class="p">,</span> <span class="n">mz_RP</span><span class="p">,</span> <span class="n">RP</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">rp_factor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a dictionary of intensity, m/z, and coordinate values from a chunk of imzML data of inhomogeneous shapes</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p: pyimzml.ImzMLParser</span>
<span class="sd">        Instace of ImzMLParser class containing imported imzML data</span>

<span class="sd">    chunk_start: int</span>
<span class="sd">        Pixel index for the start of chunk</span>

<span class="sd">    chunk_size: int</span>
<span class="sd">        Number of pixels contained in each chunk</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ms_dict: dictionary of 2 key:value pairs</span>
<span class="sd">        Key `I` contains the intensity matrix of axes pixel index and m/z bin index</span>
<span class="sd">        Key `mz` contains m/z values</span>
<span class="sd">        Key `coords` contains pixel indices and coordinate values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ms_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">chunk_start</span><span class="p">:</span><span class="n">chunk_start</span><span class="o">+</span><span class="n">chunk_size</span><span class="p">]):</span>
        <span class="n">bin_spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">int</span><span class="p">((</span><span class="n">max_mz</span><span class="o">-</span><span class="n">min_mz</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mz_RP</span><span class="o">/</span><span class="n">RP</span><span class="p">)</span> <span class="o">*</span> <span class="n">rp_factor</span><span class="p">)</span><span class="o">+</span><span class="mi">10</span><span class="p">])</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">chunk_start</span> <span class="o">+</span> <span class="n">idx</span>
        <span class="n">mzs</span><span class="p">,</span> <span class="n">intensities</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">getspectrum</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">intensity_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
            <span class="p">(</span><span class="n">mzs</span> <span class="o">-</span> <span class="n">min_mz</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mz_RP</span><span class="o">/</span><span class="n">RP</span><span class="p">)</span> <span class="o">*</span> <span class="n">rp_factor</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">bin_spectrum</span><span class="p">[</span><span class="n">intensity_index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">intensities</span>
        <span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bin_spectrum</span><span class="p">)</span>
        <span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
    <span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">])</span>
    <span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ms_dict</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">ms_dict</span></div>


<div class="viewcode-block" id="chunk_prep"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.chunk_prep">[docs]</a><span class="k">def</span> <span class="nf">chunk_prep</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">percent_RAM</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Prepares parameters used in chunking. Imports imzML datasets using pyimzml.ImzMLParser (https://github.com/alexandrovteam/pyimzML)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p :  pyimzml.ImzMLParser</span>
<span class="sd">        The data to process, converted to ImzMLParser from the .imzML raw date file.</span>
<span class="sd">    percent_RAM : int, optional</span>
<span class="sd">        percent available RAM occupied by chunk, by default 5</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    num_chunks: int</span>
<span class="sd">        Number of chunks the data needs to be devided into to optimize the use of</span>
<span class="sd">        avilable RAM on the computer.</span>
<span class="sd">    chunk_size_base: int</span>
<span class="sd">        The minimal number of columns in each chunk.</span>
<span class="sd">    chunk_start: int</span>
<span class="sd">        The row index location of where the first chunck starts in the .</span>
<span class="sd">    remainder: int</span>
<span class="sd">        The remaining columns of data after assigning each chunk a minimal number of columns.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    @software{msalign2024,</span>
<span class="sd">    author = {Fay, D.; Palmer, A. D.; Vitaly, K.; Alexandrov, T},</span>
<span class="sd">    title = {{pyimzML}:A parser for the imzML format used in imaging mass spectrometry.},</span>
<span class="sd">    url = {https://github.com/alexandrovteam/pyimzML},</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">row_spectra</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">intensityLengths</span><span class="p">)</span>
    <span class="n">col_spectra</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">intensityLengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">RAM_available</span> <span class="o">=</span> <span class="n">psutil</span><span class="o">.</span><span class="n">virtual_memory</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">num_chunks</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row_spectra</span> <span class="o">*</span> <span class="n">col_spectra</span> <span class="o">*</span>
                     <span class="c1"># ceiling</span>
                     <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">/</span> <span class="p">(</span><span class="n">RAM_available</span> <span class="o">*</span> <span class="n">percent_RAM</span><span class="o">/</span><span class="mi">100</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">chunk_size_base</span> <span class="o">=</span> <span class="n">row_spectra</span> <span class="o">//</span> <span class="n">num_chunks</span>

    <span class="n">remainder</span> <span class="o">=</span> <span class="n">row_spectra</span> <span class="o">%</span> <span class="n">num_chunks</span>

    <span class="n">chunk_start</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">num_chunks</span><span class="p">,</span> <span class="n">chunk_size_base</span><span class="p">,</span> <span class="n">chunk_start</span><span class="p">,</span> <span class="n">remainder</span></div>


<div class="viewcode-block" id="chunk_prep_inhomogeneous"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.chunk_prep_inhomogeneous">[docs]</a><span class="k">def</span> <span class="nf">chunk_prep_inhomogeneous</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">min_mz</span><span class="p">,</span> <span class="n">max_mz</span><span class="p">,</span> <span class="n">mz_RP</span><span class="p">,</span> <span class="n">RP</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">percent_RAM</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Prepares parameters used in chunking for imzML datasets of inhomogeneous shapes. Imports imzML datasets using pyimzml.ImzMLParser (https://github.com/alexandrovteam/pyimzML)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p :  pyimzml.ImzMLParser</span>
<span class="sd">        The data to process, converted to ImzMLParser from the .imzML raw date file.</span>
<span class="sd">    min_mz : float</span>
<span class="sd">        minimum m/z in inhomogeneous dataset</span>
<span class="sd">    max_mz : float</span>
<span class="sd">        maximum m/z in inhomogeneous dataset</span>
<span class="sd">    mz_RP : float</span>
<span class="sd">        m/z in which resolving power (FWHM) is calculated</span>
<span class="sd">    RP : float</span>
<span class="sd">        resolving power (FWHM) at m/z {mz_RP}</span>
<span class="sd">    dist : int</span>
<span class="sd">        minimum number of datapoints for peak separation</span>
<span class="sd">    percent_RAM : int, optional</span>
<span class="sd">        percent available RAM occupied by chunk, by default 5</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    num_chunks: int</span>
<span class="sd">        Number of chunks the data needs to be devided into to optimize the use of</span>
<span class="sd">        avilable RAM on the computer.</span>
<span class="sd">    chunk_size_base: int</span>
<span class="sd">        The minimal number of columns in each chunk.</span>
<span class="sd">    chunk_start: int</span>
<span class="sd">        The row index location of where the first chunck starts in the .</span>
<span class="sd">    remainder: int</span>
<span class="sd">        Remainder columns after chunk_size_base division</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    @software{msalign2024,</span>
<span class="sd">    author = {Fay, D.; Palmer, A. D.; Vitaly, K.; Alexandrov, T},</span>
<span class="sd">    title = {{pyimzML}: A parser for the imzML format used in imaging mass spectrometry.},</span>
<span class="sd">    url = {https://github.com/alexandrovteam/pyimzML},</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">row_spectra</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
    <span class="n">col_spectra</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">max_mz</span><span class="o">-</span><span class="n">min_mz</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mz_RP</span><span class="o">/</span><span class="n">RP</span><span class="p">)</span><span class="o">*</span><span class="n">dist</span><span class="p">)</span><span class="o">+</span><span class="mi">10</span>

    <span class="n">RAM_available</span> <span class="o">=</span> <span class="n">psutil</span><span class="o">.</span><span class="n">virtual_memory</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">num_chunks</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row_spectra</span> <span class="o">*</span> <span class="n">col_spectra</span> <span class="o">*</span>
                     <span class="c1"># ceiling</span>
                     <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">/</span> <span class="p">(</span><span class="n">RAM_available</span> <span class="o">*</span> <span class="n">percent_RAM</span><span class="o">/</span><span class="mi">100</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">chunk_size_base</span> <span class="o">=</span> <span class="n">row_spectra</span> <span class="o">//</span> <span class="n">num_chunks</span>

    <span class="n">remainder</span> <span class="o">=</span> <span class="n">row_spectra</span> <span class="o">%</span> <span class="n">num_chunks</span>

    <span class="n">chunk_start</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">num_chunks</span><span class="p">,</span> <span class="n">chunk_size_base</span><span class="p">,</span> <span class="n">chunk_start</span><span class="p">,</span> <span class="n">remainder</span></div>


<div class="viewcode-block" id="integrate_peak"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.integrate_peak">[docs]</a><span class="k">def</span> <span class="nf">integrate_peak</span><span class="p">(</span><span class="n">chunk_ms_dict</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p2_width</span><span class="p">,</span> <span class="n">chunk_0_mz_peaks</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;peak_width&quot;</span><span class="p">,</span> <span class="n">remove_duplicates</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Peak integration based on p2_width over chunk_ns_dict</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chunk_ms_dict : dict</span>
<span class="sd">        Chunking output from get_chunk_ms_info()</span>
<span class="sd">    p2 : array of int</span>
<span class="sd">        Peak indices from peak picking</span>
<span class="sd">    p2_width : np.1darray</span>
<span class="sd">        Peak regions computed by np.peak_widths</span>
<span class="sd">    chunk_0_mz_peaks : np.1darray</span>
<span class="sd">        m/z values mapped by p2</span>
<span class="sd">    method : str</span>
<span class="sd">        Peak integration method. Peak_width is currently the only supported option,</span>
<span class="sd">    remove_duplicates : bool, optional</span>
<span class="sd">        Removes duplicates of peak regions in cases of near-isobars unresolved at user-specified rel_height in peak_pick(), by default False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame</span>
<span class="sd">        Integrated intensity matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ===================== DIFFERENT INTEGRATION ALGORITHMS==========================#</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;peak_width&quot;</span><span class="p">:</span>
        <span class="n">peak_width</span> <span class="o">=</span> <span class="n">p2_width</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">peak_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">peak_width</span><span class="p">)</span>
        <span class="c1"># peak_width = np.asarray([np.ceil(peak_width[:,0]), np.floor(peak_width[:,1])]).T</span>

        <span class="k">if</span> <span class="n">remove_duplicates</span><span class="p">:</span>
            <span class="n">duplicates</span> <span class="o">=</span> <span class="p">(</span><span class="n">peak_width</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">peak_width</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">keep_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">~</span><span class="n">duplicates</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">peak_width</span> <span class="o">=</span> <span class="n">peak_width</span><span class="p">[</span><span class="n">keep_rows</span><span class="p">]</span>
            <span class="n">p2_new_temp</span> <span class="o">=</span> <span class="n">p2_new_temp</span><span class="p">[</span><span class="n">keep_rows</span><span class="p">]</span>

        <span class="n">intensity_df_temp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">chunk_ms_dict</span><span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">chunk_ms_dict</span><span class="p">[</span><span class="s1">&#39;mz&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">intensity_df_temp</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;mz&#39;</span>
        <span class="n">intensity_df_temp</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">peak_area_df_temp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="c1"># df[1:] to account for np.diff</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p2_new_temp</span><span class="p">),</span> <span class="n">intensity_df_temp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">index</span><span class="o">=</span><span class="n">chunk_0_mz_peaks</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">intensity_df_temp</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">peak_area</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">chunk_ms_dict</span><span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">][</span><span class="n">column</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">chunk_ms_dict</span><span class="p">[</span><span class="s2">&quot;mz&quot;</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">-</span><span class="n">chunk_ms_dict</span><span class="p">[</span><span class="s2">&quot;mz&quot;</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]))])</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">peak_width</span><span class="p">]</span>
            <span class="n">peak_area_df_temp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">peak_area</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;method DNE&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">peak_area_df_temp</span></div>


<div class="viewcode-block" id="get_p2"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.get_p2">[docs]</a><span class="k">def</span> <span class="nf">get_p2</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">loq</span><span class="p">,</span> <span class="n">lwr</span><span class="p">,</span> <span class="n">upr</span><span class="p">,</span> <span class="n">rel_height</span><span class="p">,</span> <span class="n">chunk_size_base</span><span class="p">,</span> <span class="n">num_chunks</span><span class="p">,</span> <span class="n">chunk_start</span><span class="p">,</span> <span class="n">remainder</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;point&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;_summary_</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p :  pyimzml.ImzMLParser</span>
<span class="sd">        The data to process, converted to ImzMLParser from the .imzML raw date file.</span>
<span class="sd">    loq : float</span>
<span class="sd">        number of times the noise level (k * noise) to define limit of quantification used in peak picking</span>
<span class="sd">    lwr : float</span>
<span class="sd">        lower m/z bound of a region in spectrum without signals</span>
<span class="sd">    upr : float</span>
<span class="sd">        upper m/z bound of a region in spectrum without signals</span>
<span class="sd">    rel_height : float, optional</span>
<span class="sd">        peak height cutoff for peak integration, by default 0.9</span>
<span class="sd">    num_chunks: int</span>
<span class="sd">        Number of chunks the data needs to be devided into to optimize the use of</span>
<span class="sd">        avilable RAM on the computer.</span>
<span class="sd">    chunk_size_base: int</span>
<span class="sd">        The minimal number of columns in each chunk.</span>
<span class="sd">    chunk_start: int</span>
<span class="sd">        The row index location of where the first chunck starts in the .</span>
<span class="sd">    remainder: int</span>
<span class="sd">        Remainder columns after chunk_size_base division</span>
<span class="sd">    dist : int</span>
<span class="sd">        Minimum number of datapoints for peak separation</span>
<span class="sd">    method of computing noise, by default &quot;point&quot;</span>
<span class="sd">        method `point` takes specified lower and upper m/z bound of a region in spectrum without signals and compute its standard deviation to define noise level</span>
<span class="sd">        method `specify_noise` takes user-specified noise level</span>
<span class="sd">        method `automatic` computes standard deviation of non-outliers (&lt; k * z_score), where k is specified by user</span>
<span class="sd">        method `binning` re-bins mass spectra (userful for compressed data with inhomogeneous shapes), then computes noise using method &quot;automatic&quot;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    p2 : np.1darray</span>
<span class="sd">        m/z bin indices corresponding to peak-picked maxima</span>
<span class="sd">    p2_width : np.1darray</span>
<span class="sd">        Peak regions computed by np.peak_widths</span>
<span class="sd">    noise : float</span>
<span class="sd">        Computed noise level used in peak-picking</span>
<span class="sd">    mzs : np.1darray</span>
<span class="sd">        m/z values element-indexed to m/z bins</span>
<span class="sd">    avg_spectrum : np.1darray</span>
<span class="sd">        Mean mass spectrum from imzML dataset</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">index_stop</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">getmz</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mf">0.999</span><span class="p">)</span>
    <span class="n">avg_spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">index_stop</span><span class="p">)</span>
    <span class="c1"># should pixel 0 be chosen? looks like mz is same across indices</span>
    <span class="n">mzs</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">getmz</span><span class="p">(</span><span class="mi">0</span><span class="p">)[:</span><span class="n">index_stop</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_chunks</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Chunk </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">chunk_size_temp</span> <span class="o">=</span> <span class="n">chunk_size_base</span>
        <span class="k">if</span> <span class="n">remainder</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">chunk_size_temp</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">intensities_chunk</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get_intensity_chunk</span><span class="p">(</span><span class="n">chunk_start</span><span class="o">=</span><span class="n">chunk_start</span><span class="p">,</span> <span class="n">chunk_end</span><span class="o">=</span><span class="p">(</span>
            <span class="n">chunk_start</span><span class="o">+</span><span class="n">chunk_size_temp</span><span class="p">),</span> <span class="n">index_stop</span><span class="o">=</span><span class="n">index_stop</span><span class="p">)</span>
        <span class="n">avg_spectrum</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">intensities_chunk</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;point&quot;</span><span class="p">:</span>
            <span class="n">noise_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">intensities_chunk</span><span class="p">)[</span>
                               <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">mzs</span> <span class="o">&gt;=</span> <span class="n">lwr</span><span class="p">,</span> <span class="n">mzs</span> <span class="o">&lt;=</span> <span class="n">upr</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">noise_bin</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">noise</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">noise_bin</span><span class="p">[</span><span class="n">noise_bin</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>

            <span class="n">chunk_start</span> <span class="o">+=</span> <span class="n">chunk_size_temp</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time used for running chunk </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> with a size of </span><span class="si">{</span><span class="n">chunk_size_temp</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

    <span class="n">avg_spectrum</span> <span class="o">/=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;point&quot;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">/=</span> <span class="n">num_chunks</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;specify_noise&quot;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Specify a noise level for peak-picking, such that loq = k * noise. &quot;</span><span class="p">)</span>

    <span class="n">p2</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">avg_spectrum</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">loq</span><span class="o">*</span><span class="n">noise</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">dist</span><span class="p">)</span>
    <span class="n">p2_width</span> <span class="o">=</span> <span class="n">peak_widths</span><span class="p">(</span><span class="n">avg_spectrum</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">rel_height</span><span class="o">=</span><span class="n">rel_height</span><span class="p">)</span>
    <span class="n">p2_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p2_width</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p2_width</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">mzs</span><span class="p">,</span> <span class="n">avg_spectrum</span></div>


<span class="c1"># ===from transfer_learning_python===#</span>

<div class="viewcode-block" id="remapping_coords"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.remapping_coords">[docs]</a><span class="k">def</span> <span class="nf">remapping_coords</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remap x,y coordinate values on arbitrary scale to minima (0, 0) with steps of 1</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.1darray</span>
<span class="sd">        x coordinate values imported from imzML dataset</span>
<span class="sd">    y : np.1darray</span>
<span class="sd">        y coordinate values imported from imzML dataset</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : np.1darray</span>
<span class="sd">        remapped x coordinate values</span>
<span class="sd">    y : np.1darray</span>
<span class="sd">        remapped y coordinate values</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="c1">#    x = x.to_numpy()</span>
<span class="c1">#    y = y.to_numpy()</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">x</span><span class="p">[</span><span class="n">x</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="n">b</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>


<div class="viewcode-block" id="make_image_1c"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.make_image_1c">[docs]</a><span class="k">def</span> <span class="nf">make_image_1c</span><span class="p">(</span><span class="n">data_2darray</span><span class="p">,</span> <span class="n">remap_coord</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Map pixel-indexed intensity values to x,y-coordinate values. Just-in-time compiler implementation</span>

<span class="sd">     Parameters</span>
<span class="sd">     ----------</span>
<span class="sd">     data_2darray : np.2darray</span>
<span class="sd">         2darray converted from intensity matrix</span>
<span class="sd">     img_array_1c : np.3darray</span>
<span class="sd">         empty 3darray to store x,y-mapped ion images</span>

<span class="sd">     Returns</span>
<span class="sd">     -------</span>
<span class="sd">     np.3darray</span>
<span class="sd">         RGB-transformed and grayscale images</span>
<span class="sd">     &quot;&quot;&quot;</span>

    <span class="n">x_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data_2darray</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">y_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data_2darray</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">remap_coord</span><span class="p">:</span>
        <span class="n">data_2darray</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_2darray</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_min</span>
        <span class="n">data_2darray</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_2darray</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_min</span>

    <span class="n">img_array_1c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">data_2darray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">data_2darray</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">data_2darray</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]))</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">max_normalize</span><span class="p">:</span>
        <span class="n">data_2darray</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_2darray</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data_2darray</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data_2darray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_2darray</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">:]):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="n">img_array_1c</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                            <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_2darray</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">img_array_1c</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Nan exists in single-channel images&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">img_array_1c</span></div>


<div class="viewcode-block" id="make_image_1c_njit"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.make_image_1c_njit">[docs]</a><span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">make_image_1c_njit</span><span class="p">(</span><span class="n">data_2darray</span><span class="p">,</span> <span class="n">img_array_1c</span><span class="p">,</span> <span class="n">remap_coord</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Map pixel-indexed intensity values to x,y-coordinate values. Just-in-time compiler implementation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_2darray : np.2darray</span>
<span class="sd">        2darray converted from intensity matrix  </span>
<span class="sd">    img_array_1c : np.3darray</span>
<span class="sd">        empty 3darray to store x,y-mapped ion images </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.3darray</span>
<span class="sd">        RGB-transformed and grayscale images</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data_2darray</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">y_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data_2darray</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">remap_coord</span><span class="p">:</span>
        <span class="n">data_2darray</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_2darray</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_min</span>
        <span class="n">data_2darray</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_2darray</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_min</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data_2darray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_2darray</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">:]):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="n">img_array_1c</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                         <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_2darray</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">img_array_1c</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">pass</span>

    <span class="k">return</span> <span class="n">img_array_1c</span></div>


<div class="viewcode-block" id="max_normalize"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.max_normalize">[docs]</a><span class="k">def</span> <span class="nf">max_normalize</span><span class="p">(</span><span class="n">data_2darray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Normalize on maximum value of each pixel </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_2darray : np.2darray</span>
<span class="sd">        2darray converted from intensity matrix extracted from imzML dataset </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.2darray</span>
<span class="sd">        max-normalized 2darray from intensity matrix extracted from imzML dataset</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data_2darray</span> <span class="o">=</span> <span class="n">data_2darray</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data_2darray</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data_2darray</span></div>


<div class="viewcode-block" id="draw_ROI"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.draw_ROI">[docs]</a><span class="k">def</span> <span class="nf">draw_ROI</span><span class="p">(</span><span class="n">ROI_info</span><span class="p">,</span> <span class="n">show_ROI</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_square</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualize selected ROI region in a green box</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ROI_info : pd.dataframe</span>
<span class="sd">        Replicate, ROI annotations, x,y coordinates from ROI selection</span>
<span class="sd">    show_ROI : bool, optional</span>
<span class="sd">        Displays ROI labels if True, by default True</span>
<span class="sd">    show_square : bool, optional</span>
<span class="sd">        Displays green box around selected ROI if True , by default False</span>
<span class="sd">    linewidth : float, optional</span>
<span class="sd">        Width of green box, by default 3</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ROI_info</span><span class="o">.</span><span class="n">columns</span> <span class="o">==</span> <span class="s2">&quot;bottom&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">truncate_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ROI_info</span><span class="o">.</span><span class="n">columns</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">squares</span> <span class="o">=</span> <span class="n">ROI_info</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">start_col</span><span class="p">:</span><span class="n">truncate_col</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">square</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">squares</span><span class="p">):</span>
        <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">square</span>
        <span class="c1"># plt.ylim(top-10, bottom+10)</span>
        <span class="c1"># plt.xlim(left-10, right+10)</span>

        <span class="n">x_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">]</span>
        <span class="n">y_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">bottom</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">show_square</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span><span class="p">,</span> <span class="s1">&#39;g-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show_ROI</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">((</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">bottom</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="n">ROI_info</span><span class="p">[</span><span class="s2">&quot;ROI&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                     <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">ROI_info</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">])</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="build_effnet"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.build_effnet">[docs]</a><span class="k">def</span> <span class="nf">build_effnet</span><span class="p">(</span><span class="n">image_array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Build a CNN feature extractor using EfficientNetV2L</span>
<span class="sd">    -----</span>
<span class="sd">    inputs:</span>
<span class="sd">        image_array: RGB images from make_image()</span>
<span class="sd">    -----</span>
<span class="sd">    outputs:</span>
<span class="sd">        EfficientNetV2L feature extractor</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">Sequential</span><span class="p">()</span>

    <span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">image_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])))</span>

    <span class="c1"># resizes the images to the expected size</span>
    <span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="o">.</span><span class="n">Lambda</span><span class="p">(</span><span class="k">lambda</span> <span class="n">image</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">))))</span>

    <span class="n">en</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">applications</span><span class="o">.</span><span class="n">efficientnet_v2</span><span class="o">.</span><span class="n">EfficientNetV2L</span><span class="p">(</span>
        <span class="n">include_top</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s2">&quot;imagenet&quot;</span><span class="p">)</span>
    <span class="n">en</span><span class="o">.</span><span class="n">trainable</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># DISABLE training of this entire layer</span>

    <span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">en</span><span class="p">)</span>

    <span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="o">.</span><span class="n">GlobalAveragePooling2D</span><span class="p">())</span>  <span class="c1"># !</span>

    <span class="k">return</span> <span class="n">model</span></div>


<div class="viewcode-block" id="gromov_trick"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.gromov_trick">[docs]</a><span class="k">def</span> <span class="nf">gromov_trick</span><span class="p">(</span><span class="n">image_array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Preprocesses each vector of images in original or CNN space for Euclidean metric</span>
<span class="sd">    -----</span>
<span class="sd">    inputs:</span>
<span class="sd">        image_array: extracted features from transfer learning or img_array_1c from make_image()</span>
<span class="sd">    -----</span>
<span class="sd">    outputs:</span>
<span class="sd">        normalized image_array for k-means clustering</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">image_array_pos</span> <span class="o">=</span> <span class="n">image_array</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">image_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">normalized_image_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">image_array_pos</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">image_array_pos</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">normalized_image_array</span></div>


<div class="viewcode-block" id="clustering_in_embedding"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.clustering_in_embedding">[docs]</a><span class="k">def</span> <span class="nf">clustering_in_embedding</span><span class="p">(</span><span class="n">image_array</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">compute_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Performs k-means clustering and t-SNE dimensionality reduction. Currently fixed parameters.</span>
<span class="sd">    -----</span>
<span class="sd">    inputs:</span>
<span class="sd">        image_array: normalized images from gromov_trick() or extracted features from transfer learning or img_array_1c from make_image()</span>
<span class="sd">    -----</span>
<span class="sd">    outputs:</span>
<span class="sd">        k-means labels and t-SNE embedding of image_array</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># k-means</span>
    <span class="n">k_means</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="s2">&quot;k-means++&quot;</span><span class="p">,</span>
                     <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">image_array</span><span class="p">)</span>
    <span class="n">kmeans_labels</span> <span class="o">=</span> <span class="n">k_means</span><span class="o">.</span><span class="n">labels_</span>

    <span class="k">if</span> <span class="n">compute_index</span><span class="p">:</span>
        <span class="n">DB_score</span> <span class="o">=</span> <span class="n">davies_bouldin_score</span><span class="p">(</span><span class="n">image_array</span><span class="p">,</span> <span class="n">kmeans_labels</span><span class="p">)</span>
        <span class="n">CH_score</span> <span class="o">=</span> <span class="n">calinski_harabasz_score</span><span class="p">(</span><span class="n">image_array</span><span class="p">,</span> <span class="n">k_means</span><span class="o">.</span><span class="n">labels_</span><span class="p">)</span>
        <span class="n">sil_score</span> <span class="o">=</span> <span class="n">silhouette_score</span><span class="p">(</span>
            <span class="n">image_array</span><span class="p">,</span> <span class="n">k_means</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">image_array</span><span class="p">))</span>
        <span class="n">elbow_score</span> <span class="o">=</span> <span class="n">k_means</span><span class="o">.</span><span class="n">inertia_</span>

        <span class="n">score_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;DB_score&quot;</span><span class="p">:</span> <span class="n">DB_score</span><span class="p">,</span> <span class="s2">&quot;CH_score&quot;</span><span class="p">:</span> <span class="n">CH_score</span><span class="p">,</span>
                      <span class="s2">&quot;sil_score&quot;</span><span class="p">:</span> <span class="n">sil_score</span><span class="p">,</span> <span class="s2">&quot;elbow_score&quot;</span><span class="p">:</span> <span class="n">elbow_score</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">score_dict</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># tSNE</span>
    <span class="n">num_iters</span> <span class="o">=</span> <span class="mi">500</span>
    <span class="n">perplexity</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">my_random_state</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">tsne</span> <span class="o">=</span> <span class="n">TSNE</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="n">num_iters</span><span class="p">,</span>
                <span class="c1"># how does the perplexity param change the results?</span>
                <span class="n">perplexity</span><span class="o">=</span><span class="n">perplexity</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">my_random_state</span><span class="p">)</span>
    <span class="n">tsne_embedding</span> <span class="o">=</span> <span class="n">tsne</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">image_array</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">compute_index</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kmeans_labels</span><span class="p">,</span> <span class="n">tsne_embedding</span><span class="p">,</span> <span class="n">score_dict</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kmeans_labels</span><span class="p">,</span> <span class="n">tsne_embedding</span><span class="p">,</span> <span class="n">score_dict</span></div>


<div class="viewcode-block" id="plot_image_at_point"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.plot_image_at_point">[docs]</a><span class="k">def</span> <span class="nf">plot_image_at_point</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">color_scheme</span><span class="o">=</span><span class="s2">&quot;inferno&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Plots a tiny image at point xy for visualization with dimensionally reduced embedding.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># dxy = np.random.rand(int(np.floor(dxy)))/50 * plt.ylim()</span>
    <span class="c1"># plt.arrow(*xy, *dxy)</span>
    <span class="n">ab</span> <span class="o">=</span> <span class="n">AnnotationBbox</span><span class="p">(</span><span class="n">OffsetImage</span><span class="p">(</span>
        <span class="n">im</span><span class="p">,</span> <span class="n">zoom</span><span class="o">=</span><span class="n">zoom</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">color_scheme</span><span class="p">),</span> <span class="n">xy</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">ab</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_spectrum"><a class="viewcode-back" href="../docs/assorted_functions.html#assorted_functions.get_spectrum">[docs]</a><span class="k">def</span> <span class="nf">get_spectrum</span><span class="p">(</span><span class="n">output_filepath</span><span class="p">,</span> <span class="n">mzs</span><span class="p">,</span> <span class="n">avg_intensity</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate interactive mean spectrum and stores at output_filepath</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    output_filepath : str</span>
<span class="sd">        file path to store spectrum </span>
<span class="sd">    mzs : np.1darray</span>
<span class="sd">        m/z values from get_p2</span>
<span class="sd">    avg_intensity : np.1darray</span>
<span class="sd">        mean spectrum from get_p2</span>
<span class="sd">    p2 : np.1darray</span>
<span class="sd">        m/z bin indices corresponding to peak-picked maxima</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output_file</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">output_filepath</span><span class="p">)</span>

    <span class="n">ms_spectrum</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">1400</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span>
                         <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Interactive mass spectrum&quot;</span><span class="p">)</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">mzs</span><span class="p">,</span> <span class="n">avg_intensity</span><span class="p">)</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">mzs</span><span class="p">[</span><span class="n">p2</span><span class="p">],</span> <span class="n">avg_intensity</span><span class="p">[</span><span class="n">p2</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="s2">&quot;m/z&quot;</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="s2">&quot;Intensity [a.u.]&quot;</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label_text_font_size</span> <span class="o">=</span> <span class="s2">&quot;26pt&quot;</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label_text_font_size</span> <span class="o">=</span> <span class="s2">&quot;26pt&quot;</span>
    <span class="c1"># Customize ticks</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">major_tick_line_color</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">major_tick_line_width</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">major_tick_in</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">major_tick_out</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">major_tick_line_color</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">major_tick_line_width</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">major_tick_in</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">major_tick_out</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">minor_tick_line_color</span> <span class="o">=</span> <span class="s2">&quot;grey&quot;</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">minor_tick_line_color</span> <span class="o">=</span> <span class="s2">&quot;grey&quot;</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">minor_tick_line_width</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">minor_tick_line_width</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">minor_tick_in</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">minor_tick_out</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">minor_tick_in</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">minor_tick_out</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">major_label_text_font_size</span> <span class="o">=</span> <span class="s2">&quot;16pt&quot;</span>
    <span class="n">ms_spectrum</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">major_label_text_font_size</span> <span class="o">=</span> <span class="s2">&quot;16pt&quot;</span>

    <span class="n">save</span><span class="p">(</span><span class="n">ms_spectrum</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, yutinlin.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>